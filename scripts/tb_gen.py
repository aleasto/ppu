# pip install posit_playground

import argparse, random, datetime, enum
from posit_playground import from_bits
from posit_playground.utils import get_bin

DECODE = 0
ENCODE = 1
X = "'bx"

NUM_RANDOM_TEST_CASES = 300


class Tb(enum.Enum):
    MUL = "mul"
    ADD = "add"
    DECODE = "decode"
    ENCODE = "encode"

    def __str__(self):
        return self.value


parser = argparse.ArgumentParser(description="Generate test benches")
parser.add_argument(
    "--operation",
    type=Tb,
    choices=list(Tb),
    required=True,
    help="Type of test bench: adder/multiplier/etc",
)
parser.add_argument(
    "--shuffle-random", type=bool, default=False, required=False, help="Shuffle random"
)

parser.add_argument(
    "--num-bits", "-n", type=int, required=True, help="Num posit bits"
)

parser.add_argument(
    "--es-size", "-es", type=int, required=True, help="Num posit bits"
)

args = parser.parse_args()



N, ES = args.num_bits, args.es_size


if args.shuffle_random == False:
    random.seed(4)


if __name__ == "__main__":

    c = f"""\t/*-------------------------------------+
    | autogenerated by tb_gen.py on       |
    | {datetime.datetime.now().strftime('%c')}            |
    +-------------------------------------*/\n"""

    list_a = random.sample(range(0, 2 ** N - 1), min(NUM_RANDOM_TEST_CASES, 2 ** N - 1))

    for (counter, a) in enumerate(list_a):
        p = from_bits(a, N, ES)

        c += f"{'test_no ='.ljust(25)} {counter+1};\n"

        if args.operation == Tb.DECODE:
            # posit bits
            c += f"{'bits ='.ljust(25)} {N}'b{get_bin(p.bit_repr(), N)};\n"
            # sign
            c += f"{'sign_expected ='.ljust(25)} {p.sign};\n"
            # regime
            c += f"{'reg_s_expected ='.ljust(25)} {p.regime.reg_s.unwrap_or(X)};\n"
            c += f"{'reg_len_expected ='.ljust(25)} {p.regime.reg_len.unwrap_or(X)};\n"
            # c += f"{'k_expected ='.ljust(25)} {p.regime.k.unwrap_or(X)};\n"
            c += f"{'regime_bits_expected ='.ljust(25)} {N}'b{get_bin(p.regime.calc_reg_bits(), N)};\n"
            # exponent
            c += f"{'exp_expected ='.ljust(25)} {N}'b{get_bin(p.exp, N)};\n"
            # mantissa
            c += f"{'mant_expected ='.ljust(25)} {N}'b{get_bin(p.mant, N)};\n"
        elif args.operation == Tb.ENCODE:
            c += f"{'posit_expected ='.ljust(25)} {N}'b{get_bin(p.bit_repr(), N)};\n"
            ### sign
            c += f"{'sign ='.ljust(25)} {p.sign};\n"
            ###Â regime
            c += f"{'reg_s ='.ljust(25)} {p.regime.reg_s.unwrap_or(X)};\n"
            c += f"{'reg_len ='.ljust(25)} {p.regime.reg_len.unwrap_or(X)};\n"
            # c += f"{'k ='.ljust(25)} {p.regime.k.unwrap_or(X)};\n"
            c += f"{'regime_bits ='.ljust(25)} {N}'b{get_bin(p.regime.calc_reg_bits(), N)};\n"
            ### exponent
            c += f"{'exp ='.ljust(25)} {N}'b{get_bin(p.exp, N)};\n"
            ### mantissa
            c += f"{'mant ='.ljust(25)} {N}'b{get_bin(p.mant, N)};\n"
            c += f"{'is_zero ='.ljust(25)} {p.is_zero.real};\n"
            c += f"{'is_inf ='.ljust(25)} {p.is_inf.real};\n"
        

        c += f"#10;\n\n"

    if ENCODE:
        filename = f"../src/tb_posit_{args.operation}_P{N}E{ES}.sv"
        with open(filename, "w") as f:
            f.write(c)
            print(f"Wrote {filename}")
