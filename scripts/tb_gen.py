# pip install posit_playground

# e.g.:
#   python tb_gen.py --operation decode -n 16 -es 1

import argparse, random, datetime, enum, pathlib
from posit_playground import from_bits
from posit_playground.utils import get_bin, get_hex

LJUST = 25

X = "'bx" # undefined / unresolved
Z = "'bz" # high impedance

NUM_RANDOM_TEST_CASES = 300


class Tb(enum.Enum):
    MUL = "mul"
    MUL_CORE = "mul_core"
    ADD = "add"
    DECODE = "decode"
    ENCODE = "encode"

    def __str__(self):
        return self.value


parser = argparse.ArgumentParser(description="Generate test benches")
parser.add_argument(
    "--operation",
    type=Tb,
    choices=list(Tb),
    required=True,
    help="Type of test bench: adder/multiplier/etc",
)
parser.add_argument(
    "--shuffle-random", type=bool, default=False, required=False, help="Shuffle random"
)

parser.add_argument("--num-bits", "-n", type=int, required=True, help="Num posit bits")

parser.add_argument("--es-size", "-es", type=int, required=True, help="Num posit bits")

args = parser.parse_args()


N, ES = args.num_bits, args.es_size


if args.shuffle_random == False:
    random.seed(4)


if __name__ == "__main__":

    c = f"""\t/*-------------------------------------+
    | autogenerated by tb_gen.py on       |
    | {datetime.datetime.now().strftime('%c')}            |
    +-------------------------------------*/\n"""

    list_a = random.sample(range(0, 2 ** N - 1), min(NUM_RANDOM_TEST_CASES, 2 ** N - 1))
    list_b = random.sample(range(0, 2 ** N - 1), min(NUM_RANDOM_TEST_CASES, 2 ** N - 1))
    # force 0 and inf to be somewhere
    # list_a[random.randint(0, N)] = 0
    # list_a[random.randint(0, N)] = 1 << (N-1)
    # list_b[random.randint(0, N)] = 0
    # list_b[random.randint(0, N)] = 1 << (N-1)
    
    list_a[0] = 0             
    list_a[1] = 1 << (N-1)    
    list_a[2], list_b[2] = 0, 1 << (N-1)

    if args.operation == Tb.DECODE or args.operation == Tb.ENCODE:
        for (counter, a) in enumerate(list_a):
            p = from_bits(a, N, ES)

            c += f"{'test_no ='.ljust(LJUST)} {counter+1};\n"

            if args.operation == Tb.DECODE:
                # posit bits
                c += f"{'bits ='.ljust(LJUST)} {N}'b{p.to_bin(prefix=False)};\n"
                # sign
                c += f"{'sign_expected ='.ljust(LJUST)} {p.sign};\n"
                # regime
                c += f"{'reg_s_expected ='.ljust(LJUST)} {p.regime.reg_s.unwrap_or(X)};\n"
                c += f"{'reg_len_expected ='.ljust(LJUST)} {p.regime.reg_len.unwrap_or(X)};\n"
                c += f"{'k_expected ='.ljust(LJUST)} {p.regime.k.unwrap_or(X)};\n"
                if p.regime.k.is_some:
                    c += f"{'k_is_pos ='.ljust(LJUST)} {(p.regime.k.unwrap() > 0).real};\n"
                # c += f"{'regime_bits_expected ='.ljust(LJUST)} {N}'b{get_bin(p.regime.calc_reg_bits(), N)};\n"
                # exponent
                if ES > 0:
                    c += f"{'exp_expected ='.ljust(LJUST)} {N}'b{get_bin(p.exp, N, prefix=False)};\n"
                # mantissa
                c += f"{'mant_expected ='.ljust(LJUST)} {N}'b{get_bin(p.mant, N, prefix=False)};\n"
                if p.mant_len != None:
                    c += f"{'mant_len_expected ='.ljust(LJUST)} {p.mant_len};\n"
                else:
                    c += f"{'mant_len_expected ='.ljust(LJUST)} 1'bx;\n"
                
                c += f"{'is_zero_expected ='.ljust(LJUST)} {p.is_zero.real};\n"
                c += f"{'is_inf_expected ='.ljust(LJUST)} {p.is_inf.real};\n"
            elif args.operation == Tb.ENCODE:
                c += (
                    f"{'posit_expected ='.ljust(LJUST)} {N}'h{p.to_hex(prefix=False)};\n"
                )
                ### sign
                c += f"{'sign ='.ljust(LJUST)} {p.sign};\n"
                ### regime
                # c += f"{'reg_s ='.ljust(LJUST)} {p.regime.reg_s.unwrap_or(X)};\n"
                c += f"{'reg_len ='.ljust(LJUST)} {p.regime.reg_len.unwrap_or(X)};\n"
                c += f"{'k ='.ljust(LJUST)} {p.regime.k.unwrap_or(X)};\n"
                # c += f"{'regime_bits ='.ljust(LJUST)} {N}'b{get_bin(p.regime.calc_reg_bits(), N, prefix=False)};\n"
                ### exponent
                if ES > 0:
                    c += f"{'exp ='.ljust(LJUST)} {N}'b{get_bin(p.exp, N, prefix=False)};\n"
                ### mantissa
                c += f"{'mant ='.ljust(LJUST)} {N}'b{get_bin(p.mant, N, prefix=False)};\n"
                c += f"{'is_zero ='.ljust(LJUST)} {p.is_zero.real};\n"
                c += f"{'is_inf ='.ljust(LJUST)} {p.is_inf.real};\n"
            c += f"#10;\n\n"

    if args.operation == Tb.MUL_CORE:
        for counter, (a, b) in enumerate(zip(list_a, list_b)):
            p1 = from_bits(a, N, ES)
            p2 = from_bits(b, N, ES)

            pout = p1 * p2

            c += f"{'test_no ='.ljust(LJUST)} {counter+1};\n\t"

            c += f"{'// p1:'.ljust(LJUST)} {p1.to_bin(prefix=False)} {p1.eval()};\n\t"
            c += f"{'p1_hex ='.ljust(LJUST)} {N}'h{get_hex(p1.bit_repr(), N//4, prefix=False)};\n\t"
            c += f"{'p1_is_zero ='.ljust(LJUST)} {p1.is_zero.real};\n\t"
            c += f"{'p1_is_inf ='.ljust(LJUST)} {p1.is_inf.real};\n\t"
            c += f"{'p1_sign ='.ljust(LJUST)} {p1.sign};\n\t"
            # c += f"{'p1_reg_s ='.ljust(LJUST)} {p1.regime.reg_s.unwrap_or(Z)};\n\t"
            c += f"{'p1_reg_len ='.ljust(LJUST)} {p1.regime.reg_len.unwrap_or(Z)};\n\t"
            c += f"{'p1_k ='.ljust(LJUST)} {p1.regime.k.unwrap_or(Z)};\n\t"
            if ES > 0:
                c += f"{'p1_exp ='.ljust(LJUST)} {p1.exp};\n\t"
            c += f"{'p1_mant ='.ljust(LJUST)} {N}'b{get_bin(p1.mant, N, prefix=False)};\n\t"

            c += f"{'// p2:'.ljust(LJUST)} {get_bin(p2.bit_repr(), N, prefix=False)} {p2.eval()};\n\t"
            c += f"{'p2_hex ='.ljust(LJUST)} {N}'h{get_hex(p2.bit_repr(), N//4, prefix=False)};\n\t"
            c += f"{'p2_is_zero ='.ljust(LJUST)} {p2.is_zero.real};\n\t"
            c += f"{'p2_is_inf ='.ljust(LJUST)} {p2.is_inf.real};\n\t"
            c += f"{'p2_sign ='.ljust(LJUST)} {p2.sign};\n\t"
            # c += f"{'p2_reg_s ='.ljust(LJUST)} {p2.regime.reg_s.unwrap_or(Z)};\n\t"
            c += f"{'p2_reg_len ='.ljust(LJUST)} {p2.regime.reg_len.unwrap_or(Z)};\n\t"
            c += f"{'p2_k ='.ljust(LJUST)} {p2.regime.k.unwrap_or(Z)};\n\t"
            if ES > 0:
                c += f"{'p2_exp ='.ljust(LJUST)} {p2.exp};\n\t"
            c += f"{'p2_mant ='.ljust(LJUST)} {N}'b{get_bin(p2.mant, N, prefix=False)};\n\t"

            c += f"{'// pout:'.ljust(LJUST)} {get_bin(pout.bit_repr(), N)} {pout.eval()};\n\t"
            c += f"{'pout_hex ='.ljust(LJUST)} {N}'h{get_hex(pout.bit_repr(), N//4, prefix=False)};\n\t"
            c += f"{'pout_is_zero_expected ='.ljust(LJUST)} {pout.is_zero.real};\n\t"
            c += f"{'pout_is_inf_expected ='.ljust(LJUST)} {pout.is_inf.real};\n\t"
            c += f"{'pout_sign_expected ='.ljust(LJUST)} {pout.sign};\n\t"
            # c += f"{'pout_reg_s_expected ='.ljust(LJUST)} {pout.regime.reg_s.unwrap_or(Z)};\n\t"
            c += f"{'pout_reg_len_expected ='.ljust(LJUST)} {pout.regime.reg_len.unwrap_or(Z)};\n\t"
            c += f"{'pout_k_expected ='.ljust(LJUST)} {pout.regime.k.unwrap_or(Z)};\n\t"
            if ES > 0:
                c += f"{'pout_exp_expected ='.ljust(LJUST)} {pout.exp};\n\t"
            c += f"{'pout_mant_expected ='.ljust(LJUST)} {N}'b{get_bin(pout.mant, N, prefix=False)};\n\t"

            c += f"#10;\n\n"

    elif args.operation == Tb.MUL:
        for counter, (a, b) in enumerate(zip(list_a, list_b)):
            p1 = from_bits(a, N, ES)
            p2 = from_bits(b, N, ES)

            pout = p1 * p2

            c += f"{'test_no ='.ljust(LJUST)} {counter+1};\n\t"
            c += f"{'// p1:'.ljust(LJUST)} {p1.to_bin(prefix=True)} {p1.eval()};\n\t"
            c += f"{'p1 ='.ljust(LJUST)} {N}'h{p1.to_hex(prefix=False)};\n\t"
            c += f"{'// p2:'.ljust(LJUST)} {p2.to_bin(prefix=True)} {p2.eval()};\n\t"
            c += f"{'p2 ='.ljust(LJUST)} {N}'h{p2.to_hex(prefix=False)};\n\t"
            c += f"{'// pout:'.ljust(LJUST)} {pout.to_bin(prefix=True)} {pout.eval()};\n\t"
            c += f"{'pout_expected ='.ljust(LJUST)} {N}'h{pout.to_hex(prefix=False)};\n\t"
            c += f"#10;\n\t"
            c += f'assert (pout === pout_expected) else $error("{p1.to_hex()} * {p2.to_hex()} failed");\n\n'

    filename = pathlib.Path(f"../test_vectors/tv_posit_{args.operation}_P{N}E{ES}.sv")
    with open(filename, "w") as f:
        f.write(c)
        print(f"Wrote {filename.resolve()}")
