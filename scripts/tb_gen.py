# pip install posit_playground

# e.g.:
#   python tb_gen.py --operation decode -n 16 -es 1

import argparse, random, datetime, enum
from posit_playground import from_bits
from posit_playground.utils import get_bin, get_hex

X = "'bx"

NUM_RANDOM_TEST_CASES = 300


class Tb(enum.Enum):
    MUL = "mul"
    MUL_CORE = "mul_core"
    ADD = "add"
    DECODE = "decode"
    ENCODE = "encode"

    def __str__(self):
        return self.value


parser = argparse.ArgumentParser(description="Generate test benches")
parser.add_argument(
    "--operation",
    type=Tb,
    choices=list(Tb),
    required=True,
    help="Type of test bench: adder/multiplier/etc",
)
parser.add_argument(
    "--shuffle-random", type=bool, default=False, required=False, help="Shuffle random"
)

parser.add_argument(
    "--num-bits", "-n", type=int, required=True, help="Num posit bits"
)

parser.add_argument(
    "--es-size", "-es", type=int, required=True, help="Num posit bits"
)

args = parser.parse_args()



N, ES = args.num_bits, args.es_size


if args.shuffle_random == False:
    random.seed(4)


if __name__ == "__main__":

    c = f"""\t/*-------------------------------------+
    | autogenerated by tb_gen.py on       |
    | {datetime.datetime.now().strftime('%c')}            |
    +-------------------------------------*/\n"""

    list_a = random.sample(range(0, 2 ** N - 1), min(NUM_RANDOM_TEST_CASES, 2 ** N - 1))

    if args.operation == Tb.DECODE or args.operation == Tb.ENCODE:
        for (counter, a) in enumerate(list_a):
            p = from_bits(a, N, ES)

            c += f"{'test_no ='.ljust(25)} {counter+1};\n"

            if args.operation == Tb.DECODE:
                # posit bits
                c += f"{'bits ='.ljust(25)} {N}'b{get_bin(p.bit_repr(), N)};\n"
                # sign
                c += f"{'sign_expected ='.ljust(25)} {p.sign};\n"
                # regime
                c += f"{'reg_s_expected ='.ljust(25)} {p.regime.reg_s.unwrap_or(X)};\n"
                c += f"{'reg_len_expected ='.ljust(25)} {p.regime.reg_len.unwrap_or(X)};\n"
                # c += f"{'k_expected ='.ljust(25)} {p.regime.k.unwrap_or(X)};\n"
                c += f"{'regime_bits_expected ='.ljust(25)} {N}'b{get_bin(p.regime.calc_reg_bits(), N)};\n"
                # exponent
                c += f"{'exp_expected ='.ljust(25)} {N}'b{get_bin(p.exp, N)};\n"
                # mantissa
                c += f"{'mant_expected ='.ljust(25)} {N}'b{get_bin(p.mant, N)};\n"
            elif args.operation == Tb.ENCODE:
                c += f"{'posit_expected ='.ljust(25)} {N}'b{get_bin(p.bit_repr(), N)};\n"
                ### sign
                c += f"{'sign ='.ljust(25)} {p.sign};\n"
                ###Â regime
                c += f"{'reg_s ='.ljust(25)} {p.regime.reg_s.unwrap_or(X)};\n"
                c += f"{'reg_len ='.ljust(25)} {p.regime.reg_len.unwrap_or(X)};\n"
                # c += f"{'k ='.ljust(25)} {p.regime.k.unwrap_or(X)};\n"
                c += f"{'regime_bits ='.ljust(25)} {N}'b{get_bin(p.regime.calc_reg_bits(), N)};\n"
                ### exponent
                c += f"{'exp ='.ljust(25)} {N}'b{get_bin(p.exp, N)};\n"
                ### mantissa
                c += f"{'mant ='.ljust(25)} {N}'b{get_bin(p.mant, N)};\n"
                c += f"{'is_zero ='.ljust(25)} {p.is_zero.real};\n"
                c += f"{'is_inf ='.ljust(25)} {p.is_inf.real};\n"
            c += f"#10;\n\n"
    
    list_b = random.sample(range(0, 2 ** N - 1), min(NUM_RANDOM_TEST_CASES, 2 ** N - 1))
    if args.operation == Tb.MUL_CORE:
        for counter, (a, b) in enumerate(zip(list_a, list_b)):
            p1 = from_bits(a, N, ES)
            p2 = from_bits(b, N, ES)

            pout = p1 * p2
            
            c += f"{'test_no ='.ljust(25)} {counter+1};\n\t"
            
            c += f"{'// p1:'.ljust(25)} {get_bin(p1.bit_repr(), N)} {get_hex(p1.bit_repr(), int(N/4))} {p1.eval()};\n\t"
            c += f"{'p1_is_zero ='.ljust(25)} {p1.is_zero.real};\n\t"
            c += f"{'p1_is_inf ='.ljust(25)} {p1.is_inf.real};\n\t"
            c += f"{'p1_sign ='.ljust(25)} {p1.sign};\n\t"
            c += f"{'p1_reg_s ='.ljust(25)} {p1.regime.reg_s.unwrap_or(X)};\n\t"
            c += f"{'p1_reg_len ='.ljust(25)} {p1.regime.reg_len.unwrap_or(X)};\n\t"
            if ES > 0:
                c += f"{'p1_exp ='.ljust(25)} {p1.exp};\n\t"
            c += f"{'p1_mant ='.ljust(25)} {N}'b{get_bin(p1.mant, N)};\n\t"


            c += f"{'// p2:'.ljust(25)} {get_bin(p2.bit_repr(), N)} {get_hex(p2.bit_repr(), int(N/4))} {p2.eval()};\n\t"
            c += f"{'p2_is_zero ='.ljust(25)} {p2.is_zero.real};\n\t"
            c += f"{'p2_is_inf ='.ljust(25)} {p2.is_inf.real};\n\t"
            c += f"{'p2_sign ='.ljust(25)} {p2.sign};\n\t"
            c += f"{'p2_reg_s ='.ljust(25)} {p2.regime.reg_s.unwrap_or(X)};\n\t"
            c += f"{'p2_reg_len ='.ljust(25)} {p2.regime.reg_len.unwrap_or(X)};\n\t"
            if ES > 0:
                c += f"{'p2_exp ='.ljust(25)} {p2.exp};\n\t"
            c += f"{'p2_mant ='.ljust(25)} {N}'b{get_bin(p2.mant, N)};\n\t"

            c += f"{'// pout:'.ljust(25)} {get_bin(pout.bit_repr(), N)} {get_hex(pout.bit_repr(), int(N/4))} {pout.eval()};\n\t"
            c += f"{'pout_is_zero_expected ='.ljust(25)} {pout.is_zero.real};\n\t"
            c += f"{'pout_is_inf_expected ='.ljust(25)} {pout.is_inf.real};\n\t"
            c += f"{'pout_sign_expected ='.ljust(25)} {pout.sign};\n\t"
            c += f"{'pout_reg_s_expected ='.ljust(25)} {pout.regime.reg_s.unwrap_or(X)};\n\t"
            c += f"{'pout_reg_len_expected ='.ljust(25)} {pout.regime.reg_len.unwrap_or(X)};\n\t"
            if ES > 0:
                c += f"{'pout_exp_expected ='.ljust(25)} {pout.exp};\n\t"
            c += f"{'pout_mant_expected ='.ljust(25)} {N}'b{get_bin(pout.mant, N)};\n\t"
            
            c += f"#10;\n\n"




    filename = f"../src/tb_posit_{args.operation}_P{N}E{ES}.sv"
    with open(filename, "w") as f:
        f.write(c)
        print(f"Wrote {filename}")
