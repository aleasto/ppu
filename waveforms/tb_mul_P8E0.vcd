$date
	Mon Dec 13 10:13:30 2021
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module tb_mul $end
$var wire 8 ! pout [7:0] $end
$var reg 8 " p1 [7:0] $end
$var reg 8 # p2 [7:0] $end
$scope module mul_inst $end
$var wire 8 $ p1 [7:0] $end
$var wire 2 % p1_exp [-1:0] $end
$var wire 8 & p2 [7:0] $end
$var wire 2 ' p2_exp [-1:0] $end
$var wire 8 ( p2_mant [7:0] $end
$var wire 8 ) pout [7:0] $end
$var wire 1 * p2_sign $end
$var wire 1 + p2_reg_s $end
$var wire 3 , p2_reg_len [2:0] $end
$var wire 8 - p2_reg_bits [7:0] $end
$var wire 8 . p2_k [7:0] $end
$var wire 1 / p1_sign $end
$var wire 1 0 p1_reg_s $end
$var wire 3 1 p1_reg_len [2:0] $end
$var wire 8 2 p1_reg_bits [7:0] $end
$var wire 8 3 p1_mant [7:0] $end
$var wire 8 4 p1_k [7:0] $end
$scope module mul_core_inst $end
$var wire 8 5 exp [7:0] $end
$var wire 1 6 exp_carry $end
$var wire 1 7 exp_carry_I $end
$var wire 16 8 mant_fraction_only [15:0] $end
$var wire 1 9 p1_is_inf $end
$var wire 1 : p1_is_zero $end
$var wire 1 ; p2_is_inf $end
$var wire 1 < p2_is_zero $end
$var wire 8 = p2_mant [7:0] $end
$var wire 1 > pout_is_inf $end
$var wire 1 ? pout_is_zero $end
$var wire 8 @ pout_k [7:0] $end
$var wire 8 A pout_mant [7:0] $end
$var wire 3 B pout_reg_len [2:0] $end
$var wire 1 C pout_reg_s $end
$var wire 8 D pout_regime_bits [7:0] $end
$var wire 1 E pout_sign $end
$var wire 3 F reg_len [2:0] $end
$var wire 1 G prod_mantissae_adjusted $end
$var wire 16 H prod_mantissae [15:0] $end
$var wire 1 * p2_sign $end
$var wire 8 I p2_regime_bits [7:0] $end
$var wire 1 + p2_reg_s $end
$var wire 3 J p2_reg_len [2:0] $end
$var wire 8 K p2_k [7:0] $end
$var wire 1 / p1_sign $end
$var wire 8 L p1_regime_bits [7:0] $end
$var wire 1 0 p1_reg_s $end
$var wire 3 M p1_reg_len [2:0] $end
$var wire 8 N p1_mant [7:0] $end
$var wire 8 O p1_k [7:0] $end
$var wire 8 P mant_len [7:0] $end
$var wire 1 Q mant_carry $end
$var wire 8 R k_adjusted_III [7:0] $end
$var wire 8 S k_adjusted_II [7:0] $end
$var wire 8 T k_adjusted_I [7:0] $end
$var wire 8 U k [7:0] $end
$var wire 8 V final_mant [7:0] $end
$var wire 8 W f2 [7:0] $end
$var wire 8 X f1 [7:0] $end
$var wire 8 Y exp_adjusted_III [7:0] $end
$var wire 8 Z exp_adjusted_II [7:0] $end
$var wire 8 [ exp_adjusted_I [7:0] $end
$var wire 3 \ F2 [2:0] $end
$var wire 3 ] F1 [2:0] $end
$scope function max $end
$var reg 8 ^ a [7:0] $end
$var reg 8 _ b [7:0] $end
$upscope $end
$scope function min $end
$var reg 8 ` a [7:0] $end
$var reg 8 a b [7:0] $end
$upscope $end
$upscope $end
$scope module posit_decode_p1 $end
$var wire 8 b bits [7:0] $end
$var wire 2 c exp [-1:0] $end
$var wire 8 d u_bits [7:0] $end
$var wire 1 / sign $end
$var wire 8 e regime_bits [7:0] $end
$var wire 1 0 reg_s $end
$var wire 3 f reg_len [2:0] $end
$var wire 8 g mant [7:0] $end
$var wire 3 h leading_zeros [2:0] $end
$var wire 3 i leading_ones [2:0] $end
$var wire 8 j k [7:0] $end
$var wire 1 k is_zero $end
$var wire 1 l is_inf $end
$scope function c2 $end
$var reg 8 m a [7:0] $end
$upscope $end
$scope function min $end
$var reg 8 n a [7:0] $end
$var reg 8 o b [7:0] $end
$upscope $end
$scope module clo_inst_o $end
$var wire 8 p bits [7:0] $end
$var wire 3 q leading_ones [2:0] $end
$var wire 3 r index_highest_set [2:0] $end
$scope module highest_set_inst $end
$var wire 8 s bits [7:0] $end
$var wire 3 t index [2:0] $end
$scope begin _gen[0] $end
$upscope $end
$scope begin _gen[1] $end
$upscope $end
$scope begin _gen[2] $end
$upscope $end
$scope begin _gen[3] $end
$upscope $end
$scope begin _gen[4] $end
$upscope $end
$scope begin _gen[5] $end
$upscope $end
$scope begin _gen[6] $end
$upscope $end
$scope begin _gen[7] $end
$upscope $end
$upscope $end
$upscope $end
$scope module clo_inst_z $end
$var wire 8 u bits [7:0] $end
$var wire 3 v leading_ones [2:0] $end
$var wire 3 w index_highest_set [2:0] $end
$scope module highest_set_inst $end
$var wire 8 x bits [7:0] $end
$var wire 3 y index [2:0] $end
$scope begin _gen[0] $end
$upscope $end
$scope begin _gen[1] $end
$upscope $end
$scope begin _gen[2] $end
$upscope $end
$scope begin _gen[3] $end
$upscope $end
$scope begin _gen[4] $end
$upscope $end
$scope begin _gen[5] $end
$upscope $end
$scope begin _gen[6] $end
$upscope $end
$scope begin _gen[7] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module posit_decode_p2 $end
$var wire 8 z bits [7:0] $end
$var wire 2 { exp [-1:0] $end
$var wire 8 | mant [7:0] $end
$var wire 8 } u_bits [7:0] $end
$var wire 1 * sign $end
$var wire 8 ~ regime_bits [7:0] $end
$var wire 1 + reg_s $end
$var wire 3 !" reg_len [2:0] $end
$var wire 3 "" leading_zeros [2:0] $end
$var wire 3 #" leading_ones [2:0] $end
$var wire 8 $" k [7:0] $end
$var wire 1 %" is_zero $end
$var wire 1 &" is_inf $end
$scope function c2 $end
$var reg 8 '" a [7:0] $end
$upscope $end
$scope function min $end
$var reg 8 (" a [7:0] $end
$var reg 8 )" b [7:0] $end
$upscope $end
$scope module clo_inst_o $end
$var wire 8 *" bits [7:0] $end
$var wire 3 +" leading_ones [2:0] $end
$var wire 3 ," index_highest_set [2:0] $end
$scope module highest_set_inst $end
$var wire 8 -" bits [7:0] $end
$var wire 3 ." index [2:0] $end
$scope begin _gen[0] $end
$upscope $end
$scope begin _gen[1] $end
$upscope $end
$scope begin _gen[2] $end
$upscope $end
$scope begin _gen[3] $end
$upscope $end
$scope begin _gen[4] $end
$upscope $end
$scope begin _gen[5] $end
$upscope $end
$scope begin _gen[6] $end
$upscope $end
$scope begin _gen[7] $end
$upscope $end
$upscope $end
$upscope $end
$scope module clo_inst_z $end
$var wire 8 /" bits [7:0] $end
$var wire 3 0" leading_ones [2:0] $end
$var wire 3 1" index_highest_set [2:0] $end
$scope module highest_set_inst $end
$var wire 8 2" bits [7:0] $end
$var wire 3 3" index [2:0] $end
$scope begin _gen[0] $end
$upscope $end
$scope begin _gen[1] $end
$upscope $end
$scope begin _gen[2] $end
$upscope $end
$scope begin _gen[3] $end
$upscope $end
$scope begin _gen[4] $end
$upscope $end
$scope begin _gen[5] $end
$upscope $end
$scope begin _gen[6] $end
$upscope $end
$scope begin _gen[7] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module posit_encode_inst $end
$var wire 2 4" exp [-1:0] $end
$var wire 1 5" is_inf $end
$var wire 1 6" is_zero $end
$var wire 8 7" k [7:0] $end
$var wire 8 8" mant [7:0] $end
$var wire 3 9" reg_len [2:0] $end
$var wire 1 :" reg_s $end
$var wire 8 ;" regime_bits [7:0] $end
$var wire 1 <" sign $end
$var wire 8 =" posit [7:0] $end
$var wire 8 >" bits_assembled [7:0] $end
$var wire 8 ?" bits [7:0] $end
$scope function c2 $end
$var reg 8 @" a [7:0] $end
$upscope $end
$scope function shl $end
$var reg 8 A" bits [7:0] $end
$var reg 8 B" rhs [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx B"
b0zz A"
b0xxxxxxx @"
bx ?"
bx >"
bx ="
z<"
bz ;"
z:"
bz 9"
bz 8"
bz 7"
z6"
z5"
bz 4"
b111 3"
b11000 2"
b111 1"
b0 0"
b11000 /"
b100 ."
b11100110 -"
b100 ,"
b11 +"
b11100110 *"
b111 )"
b11111111 ("
b10 '"
0&"
0%"
b10 $"
b11 #"
b0 ""
b100 !"
b1110 ~
b1110011 }
b0xx |
b0 {
b1110011 z
b111 y
b11010 x
b111 w
b0 v
b11010 u
b100 t
b11100100 s
b100 r
b11 q
b11100100 p
b111 o
b11111111 n
b10 m
0l
0k
b10 j
b11 i
b0 h
b10 g
b100 f
b1110 e
b1110010 d
b0 c
b1110010 b
b110 a
b100 `
b11111010 _
b100 ^
b11 ]
b11 \
b0 [
b0x Z
b0x Y
b10100000 X
b1xxx0000 W
b0 V
b100 U
b100 T
b100 S
b100 R
xQ
b1 P
b10 O
b10 N
b100 M
b1110 L
b10 K
b100 J
b1110 I
bx H
xG
b110 F
0E
b0 D
0C
b0 B
b0xx A
b100 @
x?
x>
bz =
z<
z;
z:
z9
b0x 8
07
06
b0 5
b10 4
b10 3
b1110 2
b100 1
10
0/
b10 .
b1110 -
b100 ,
1+
0*
bx )
b0xx (
b0 '
b1110011 &
b0 %
b1110010 $
b1110011 #
b1110010 "
bx !
$end
#10
b0x 8
b111 P
b0x Y
xG
b0 F
b0x Z
xQ
b11 h
b11 v
b110 @
b110 R
bx H
b1xxxx000 W
b10 ""
b10 0"
b0 i
b0 q
b100 w
b100 y
b11111011 `
b11111011 ^
b0 #"
b0 +"
b101 1"
b101 3"
b11 ]
b111 r
b111 t
b11111011 S
b100 \
b111 ,"
b111 ."
b100 n
b100 1
b100 M
b100 f
b11 ("
b11111011 T
b0xx (
b0xx A
b0xx |
b11 ,
b11 J
b11 !"
b11111101 4
b11111101 O
b11111101 j
b11100000 X
b11100010 u
b11100010 x
b11111011 U
b11111110 .
b11111110 K
b11111110 $"
b11011000 /"
b11011000 2"
00
b1 2
b1 L
b1 e
b11100 p
b11100 s
0+
b1 -
b1 I
b1 ~
b100110 *"
b100110 -"
b110 3
b110 N
b110 g
1E
b11111110 '"
b10011 }
1/
b11111101 m
b1110 d
b10011 #
b10011 &
b10011 z
b11110010 "
b11110010 $
b11110010 b
#30
