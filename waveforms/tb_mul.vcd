$date
	Mon Dec 13 09:43:32 2021
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module tb_mul $end
$var wire 8 ! pout [7:0] $end
$var reg 8 " p1 [7:0] $end
$var reg 8 # p2 [7:0] $end
$scope module mul_inst $end
$var wire 8 $ p1 [7:0] $end
$var wire 8 % p2 [7:0] $end
$var wire 1 & p2_exp $end
$var wire 8 ' p2_mant [7:0] $end
$var wire 8 ( pout [7:0] $end
$var wire 1 ) p2_sign $end
$var wire 1 * p2_reg_s $end
$var wire 3 + p2_reg_len [2:0] $end
$var wire 8 , p2_reg_bits [7:0] $end
$var wire 8 - p2_k [7:0] $end
$var wire 1 . p1_sign $end
$var wire 1 / p1_reg_s $end
$var wire 3 0 p1_reg_len [2:0] $end
$var wire 8 1 p1_reg_bits [7:0] $end
$var wire 8 2 p1_mant [7:0] $end
$var wire 8 3 p1_k [7:0] $end
$var wire 1 4 p1_exp $end
$scope module mul_core_inst $end
$var wire 16 5 mant_fraction_only [15:0] $end
$var wire 1 6 p1_is_inf $end
$var wire 1 7 p1_is_zero $end
$var wire 1 8 p2_exp $end
$var wire 1 9 p2_is_inf $end
$var wire 1 : p2_is_zero $end
$var wire 8 ; p2_mant [7:0] $end
$var wire 1 & pout_exp $end
$var wire 1 < pout_is_inf $end
$var wire 1 = pout_is_zero $end
$var wire 8 > pout_k [7:0] $end
$var wire 8 ? pout_mant [7:0] $end
$var wire 3 @ pout_reg_len [2:0] $end
$var wire 1 A pout_reg_s $end
$var wire 8 B pout_regime_bits [7:0] $end
$var wire 1 C pout_sign $end
$var wire 3 D reg_len [2:0] $end
$var wire 1 E prod_mantissae_adjusted $end
$var wire 16 F prod_mantissae [15:0] $end
$var wire 1 ) p2_sign $end
$var wire 8 G p2_regime_bits [7:0] $end
$var wire 1 * p2_reg_s $end
$var wire 3 H p2_reg_len [2:0] $end
$var wire 8 I p2_k [7:0] $end
$var wire 1 . p1_sign $end
$var wire 8 J p1_regime_bits [7:0] $end
$var wire 1 / p1_reg_s $end
$var wire 3 K p1_reg_len [2:0] $end
$var wire 8 L p1_mant [7:0] $end
$var wire 8 M p1_k [7:0] $end
$var wire 1 4 p1_exp $end
$var wire 1 N mant_len $end
$var wire 1 O mant_carry $end
$var wire 8 P k_adjusted_III [7:0] $end
$var wire 8 Q k_adjusted_II [7:0] $end
$var wire 8 R k_adjusted_I [7:0] $end
$var wire 8 S k [7:0] $end
$var wire 8 T final_mant [7:0] $end
$var wire 8 U f2 [7:0] $end
$var wire 8 V f1 [7:0] $end
$var wire 1 W exp_carry_I $end
$var wire 1 X exp_carry $end
$var wire 8 Y exp_adjusted_III [7:0] $end
$var wire 8 Z exp_adjusted_II [7:0] $end
$var wire 8 [ exp_adjusted_I [7:0] $end
$var wire 8 \ exp [7:0] $end
$var wire 3 ] F2 [2:0] $end
$var wire 3 ^ F1 [2:0] $end
$scope function max $end
$var reg 8 _ a [7:0] $end
$var reg 8 ` b [7:0] $end
$upscope $end
$scope function min $end
$var reg 8 a a [7:0] $end
$var reg 8 b b [7:0] $end
$upscope $end
$upscope $end
$scope module posit_decode_p1 $end
$var wire 8 c bits [7:0] $end
$var wire 8 d u_bits [7:0] $end
$var wire 1 . sign $end
$var wire 8 e regime_bits [7:0] $end
$var wire 1 / reg_s $end
$var wire 3 f reg_len [2:0] $end
$var wire 8 g mant [7:0] $end
$var wire 3 h leading_zeros [2:0] $end
$var wire 3 i leading_ones [2:0] $end
$var wire 8 j k [7:0] $end
$var wire 1 k is_zero $end
$var wire 1 l is_inf $end
$var wire 1 4 exp $end
$scope function c2 $end
$var reg 8 m a [7:0] $end
$upscope $end
$scope function min $end
$var reg 8 n a [7:0] $end
$var reg 8 o b [7:0] $end
$upscope $end
$scope module clo_inst_o $end
$var wire 8 p bits [7:0] $end
$var wire 3 q leading_ones [2:0] $end
$var wire 3 r index_highest_set [2:0] $end
$scope module highest_set_inst $end
$var wire 8 s bits [7:0] $end
$var wire 3 t index [2:0] $end
$scope begin _gen[0] $end
$upscope $end
$scope begin _gen[1] $end
$upscope $end
$scope begin _gen[2] $end
$upscope $end
$scope begin _gen[3] $end
$upscope $end
$scope begin _gen[4] $end
$upscope $end
$scope begin _gen[5] $end
$upscope $end
$scope begin _gen[6] $end
$upscope $end
$scope begin _gen[7] $end
$upscope $end
$upscope $end
$upscope $end
$scope module clo_inst_z $end
$var wire 8 u bits [7:0] $end
$var wire 3 v leading_ones [2:0] $end
$var wire 3 w index_highest_set [2:0] $end
$scope module highest_set_inst $end
$var wire 8 x bits [7:0] $end
$var wire 3 y index [2:0] $end
$scope begin _gen[0] $end
$upscope $end
$scope begin _gen[1] $end
$upscope $end
$scope begin _gen[2] $end
$upscope $end
$scope begin _gen[3] $end
$upscope $end
$scope begin _gen[4] $end
$upscope $end
$scope begin _gen[5] $end
$upscope $end
$scope begin _gen[6] $end
$upscope $end
$scope begin _gen[7] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module posit_decode_p2 $end
$var wire 8 z bits [7:0] $end
$var wire 1 & exp $end
$var wire 8 { mant [7:0] $end
$var wire 8 | u_bits [7:0] $end
$var wire 1 ) sign $end
$var wire 8 } regime_bits [7:0] $end
$var wire 1 * reg_s $end
$var wire 3 ~ reg_len [2:0] $end
$var wire 3 !" leading_zeros [2:0] $end
$var wire 3 "" leading_ones [2:0] $end
$var wire 8 #" k [7:0] $end
$var wire 1 $" is_zero $end
$var wire 1 %" is_inf $end
$scope function c2 $end
$var reg 8 &" a [7:0] $end
$upscope $end
$scope function min $end
$var reg 8 '" a [7:0] $end
$var reg 8 (" b [7:0] $end
$upscope $end
$scope module clo_inst_o $end
$var wire 8 )" bits [7:0] $end
$var wire 3 *" leading_ones [2:0] $end
$var wire 3 +" index_highest_set [2:0] $end
$scope module highest_set_inst $end
$var wire 8 ," bits [7:0] $end
$var wire 3 -" index [2:0] $end
$scope begin _gen[0] $end
$upscope $end
$scope begin _gen[1] $end
$upscope $end
$scope begin _gen[2] $end
$upscope $end
$scope begin _gen[3] $end
$upscope $end
$scope begin _gen[4] $end
$upscope $end
$scope begin _gen[5] $end
$upscope $end
$scope begin _gen[6] $end
$upscope $end
$scope begin _gen[7] $end
$upscope $end
$upscope $end
$upscope $end
$scope module clo_inst_z $end
$var wire 8 ." bits [7:0] $end
$var wire 3 /" leading_ones [2:0] $end
$var wire 3 0" index_highest_set [2:0] $end
$scope module highest_set_inst $end
$var wire 8 1" bits [7:0] $end
$var wire 3 2" index [2:0] $end
$scope begin _gen[0] $end
$upscope $end
$scope begin _gen[1] $end
$upscope $end
$scope begin _gen[2] $end
$upscope $end
$scope begin _gen[3] $end
$upscope $end
$scope begin _gen[4] $end
$upscope $end
$scope begin _gen[5] $end
$upscope $end
$scope begin _gen[6] $end
$upscope $end
$scope begin _gen[7] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$scope module posit_encode_inst $end
$var wire 1 3" exp $end
$var wire 1 4" is_inf $end
$var wire 1 5" is_zero $end
$var wire 8 6" k [7:0] $end
$var wire 8 7" mant [7:0] $end
$var wire 3 8" reg_len [2:0] $end
$var wire 1 9" reg_s $end
$var wire 8 :" regime_bits [7:0] $end
$var wire 1 ;" sign $end
$var wire 8 <" posit [7:0] $end
$var wire 8 =" bits_assembled [7:0] $end
$var wire 8 >" bits [7:0] $end
$scope function c2 $end
$var reg 8 ?" a [7:0] $end
$upscope $end
$scope function shl $end
$var reg 8 @" bits [7:0] $end
$var reg 8 A" rhs [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx A"
b0z @"
b0xxxxxxx ?"
bx >"
bx ="
bx <"
z;"
bz :"
z9"
bz 8"
bz 7"
bz 6"
z5"
z4"
z3"
bx 2"
bx0 1"
bx 0"
bx /"
bx0 ."
bx -"
bx0 ,"
bx +"
bx *"
bx0 )"
b111 ("
bx '"
b0xxx &"
x%"
x$"
bx #"
bx ""
bx !"
bx ~
bx }
bx |
bx {
bx z
bx y
bx0 x
bx w
bx v
bx0 u
bx t
bx0 s
bx r
bx q
bx0 p
b111 o
bx n
b0xxx m
xl
xk
bx j
bx i
bx h
bx g
bx f
bx e
bx d
bx c
b110 b
bx a
b11111010 `
bx _
bx ^
bx ]
bx \
bx [
bx Z
bx Y
xX
xW
b1xxxxxxx V
b1xxxxxxx U
bx T
bx S
bx R
bx Q
bx P
xO
xN
bx M
bx L
bx K
bx J
bx I
bx H
bx G
bx F
xE
bx D
xC
b0 B
0A
b0 @
bx ?
bx >
x=
x<
bz ;
z:
z9
z8
z7
z6
b0x 5
x4
bx 3
bx 2
bx 1
bx 0
x/
x.
bx -
bx ,
bx +
x*
x)
bx (
bx '
x&
bx %
bx $
bx #
bx "
bx !
$end
#10
